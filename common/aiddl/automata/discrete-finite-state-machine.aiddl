(#mod self org.aiddl.common.automata.discrete-finite-state-machine)

(#nms EVAL org.aiddl.eval)

(#req C org.aiddl.common)
(#req FL org.aiddl.common.reasoning.logic.first-order)

(#def State (type #self {^symbolic ^Atom@FL}))
(#def Event (type #self {^symbolic ^Atom@FL}))

(#def States
  (and
    (type #self set)
    (forall ?e #self (type ?e $State)) ))

(#def Events
  (and
    (type #self set)
    (forall ?e #self (type ?e $Event)) ))

(#def Transitions
  (and
    (type #self set)
    (forall ?e #self
      (and
        (type ?e key-value)
        (match (?s ?a) : ?s_next ?e
          (type ?s $State)
          (type ?a $Event)
          (type ?s_next $State) )
        (forall ?k : ?v1 #self
          (not
            (exists ?k : ?v2 #self
              (not
                (= ?v1 ?v2)))))))))

(#def DFA
  (and
    (type #self ^tuple)
    (match (?Q ?E ?D ?q0 ?F) #self
      (and
        (type ?Q  ^$States)
        (type ?E  ^$Events)
        (type ?D  ^$Transitions)
        (forall (?s ?e) : ?s_next, ?D
          (and
            (in ?s ?Q)
            (in ?e ?E)
            (in ?s_next ?Q)))
        (type ?q0 ^$State)
        (type ?F  ^$States)
        (forall ?s ?F (in ?s ?Q))
        (in ?q0 ?Q)
      ))))

(#def DfaControllerArgument
  (and
    (type #self ^tuple)
    (> (size #self) 0)
    (let [?Op:(get-idx 0 #self)]
      (cond
        (= ?Op step):(type (get-idx 1 #self) ^$Event)
        (= ?Op multi-step):(type (get-idx 1 #self) (ListGen@C ^$Event))
        (= ?Op is-final-state):(= (size #self) 1)))))

(#def DfaControllerResponse
  (or
    (type #self ^boolean)
    (type #self ^$State)))

(#interface
  dfa-control
  (
    uri:org.aiddl.common.automata.dfa.controller
    input:^$DfaControllerArgument
    output:^$DfaControllerResponse
  ))