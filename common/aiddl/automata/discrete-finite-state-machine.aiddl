(#mod self org.aiddl.common.automata.discrete-finite-state-machine)

(#req EVAL org.aiddl.eval.namespace)
(#nms E basic@EVAL)

(#req C org.aiddl.common)
(#req FL org.aiddl.common.reasoning.logic.first-order)

(#type State (type.union {^symbolic ^Atom@FL}))
(#type Event (type.union {^symbolic ^Atom@FL}))

(#type States (type.set ^$State))
(#type Events (type.set ^$Event))

(#type Transition  (type.kvp (type.sig [^$State ^$Event]):^$State))
(#type Transitions (type.set ^$Transition
                              constraint:(lambda ?X
                                           (forall ?k:?v1 ?X
                                             (not (exists ?k:?v2 ?X
                                               (!= ?v1 ?v2)))))))

(#type DFA (type.sig [^$States ^$Events ^$Transitions ^$State ^$States]
  constraint:(lambda ?X 
    (match (?Q ?E ?D ?q0 ?F) ?X
      (and
        (forall (?s ?e) : ?s_next, ?D
          (and
            (in ?s ?Q)
            (in ?e ?E)
            (in ?s_next ?Q)))
        (forall ?s ?F (in ?s ?Q))
        (in ?q0 ?Q)
      )))))

(#def DfaControllerArgument
  (or
    (in #self {is-final-state current-state})
  (and
    (has-type #self ^tuple)
    (> (size #self) 0)
    (let [?Op:(get-idx 0 #self)]
      (cond
        (= ?Op step):((has-type (get-idx 1 #self) ^$Event))
        (= ?Op multi-step):(has-type (get-idx 1 #self) (ListGen@C ^$Event))
     )))))

(#def DfaControllerResponse
  (or
    (has-type #self ^boolean)
    (has-type #self ^$State)))

(#interface
  dfa-control
  (
    uri:org.aiddl.common.automata.dfa.controller
    input:^$DfaControllerArgument
    output:^$DfaControllerResponse
  ))