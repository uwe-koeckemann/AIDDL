(#mod self org.aiddl.common.domain)

;; Finite sets of values & expressions that can be expanded into finite sets.
;; Domains are sets of key-values that attach value sets to types. Signatures
;; attach types to tuples (t1 t2 t3) or key-value pairs (t1 t2 t3):t4 This can
;; be used to limit the scope of legal assignments of atomics in logic or
;; state-variable assignments in planning.

(#namespace EVAL org.aiddl.eval)

(#def EnumValues
  (and
    (has-type #self {#set #list})
    (forall ?e #self
      (has-type ?e { #symbolic #numerical #variable #string $DomainValues } )) ))

(#def IntegerValues
  (and
    (has-type #self #set)
    (has-type (get min ?R) #integer)
    (has-type (get max ?R) #integer) ))
      
(#def RationalValues
  (and
    (has-type #self #set)
    (has-type (get min #self) #rational)
    (has-type (get inc #self) #rational)
    (>= (get inc #self) 0/1)  
    (has-type (get max #self) #rational) ))
      
(#def RealValues
  (and 
    (has-type (get min #self) #real)
    (has-type (get inc #self) #real)
    (>=   (get inc #self) 0.0)
    (has-type (get max #self) #real) ))

(#def NumericalValues
  (and
    (has-type #self {
      $IntegerDomain
      $RealDomain
      $RationalDomain})))
      
(#def TupleValues
  (and
    (has-type #self #tuple)
    (forall ?e #self
      (has-type ?e {symbolic $Domain}) )))
    
(#def KeyValueValues
  (and
    (has-type #self #key-value-pair)
    (has-type (key #self)   {symbolic $Domain})
    (has-type (value #self) {symbolic $Domain}) ))
    
(#def DomainValues
  (has-type #self
    { $Enum
      $Numerical
      $Tuple
      $KeyValue }))

(#def Domains
  (and  
    (has-type #self ^collection)
    (forall ?X:?D #self
      (and
        (has-type ?D $DomainValues)))))        

(#def TupleSignature
    (and
      (has-type #self ^tuple)
      (forall ?e #self
        (has-type ?e { ^symbolic } ) )))

(#def StateVariableSignature
  (and 
    (has-type #self key-value)
    (has-type (key #self)   { ^$TupleSignature } )
    (has-type (value #self) { ^symbolic } ) ))

(#def Signatures
  (and
    (has-type #self ^set)
    (forall ?e #self (has-type ?e ^$TupleSignature ^$StateVariableSignature))))

      
  




