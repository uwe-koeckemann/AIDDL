(#mod self org.aiddl.common.learning.supervised)

(#nms EVAL org.aiddl.eval)

(#req T  org.aiddl.common.domain)
(#req FoL  org.aiddl.common.reasoning.logic.first-order)
(#req LA org.aiddl.common.math.linear-algebra)

(#type WildcardDomain (type.enum {*}))

(#type Attribute ^term)
(#type Type ^fun-ref)

(#type Attributes (type.list ^$Attributes))
(#type Class      (type.union [^symbolic ^Atom@FoL] ))

(#type DataPoint #list)

(#type RegressionProblem
  (type.kv-tuple [attributes:^$Attributes
                  label:^term
                  data:(type.matrix cell-type:^numerical)]
                  constraint:(lambda ?X
                                (let [ ?Atts:(get-key ?X)
                                       ?Label:(get-key ?X)
                                       ?Data:(get-key ?X) ]
                                     (and
                                       (exists (?Label _) ?Atts true)
                                       (= (size ?Atts) (size (first ?Data)))
                                       (forall ?Datapoint ?Data
                                         (and
                                           (zip (?Att ?Val) [?Atts ?Datapoint]
                                             (match (?Var ?Domain) ?Att
                                               (and
                                                 (type ?Val ?Domain) ))))))))))

(#type ClassificationProblem
  (type.kv-tuple [attributes:^$Attributes
                  label:^term
                  data:(type.matrix cell-type:^$Class)]
                  constraint:(lambda ?X
                                (let [ ?Atts:(get-key ?X)
                                       ?Label:(get-key ?X)
                                       ?Data:(get-key ?X) ]
                                     (and
                                       (exists (?Label _) ?Atts true)
                                       (= (size ?Atts) (size (first ?Data)))
                                       (forall ?Datapoint ?Data
                                         (and
                                           (zip (?Att ?Val) [?Atts ?Datapoint]
                                             (match (?Var ?Domain) ?Att
                                               (and
                                                 (type ?Val ?Domain) ))))))))))
                                                 
(#type Problem
  (type.kv-tuple [attributes:^$Attributes
                  label:^term
                  data:(type.matrix)
                  constraint:(lambda ?X
                                (let [ ?Atts:(get-key ?X)
                                       ?Label:(get-key ?X)
                                       ?Data:(get-key ?X) ]
                                     (and
                                       (exists (?Label _) ?Atts true)
                                       (= (size ?Atts) (size (first ?Data)))
                                       (forall ?Datapoint ?Data
                                         (and
                                           (zip (?Att ?Val) [?Atts ?Datapoint]
                                             (match (?Var ?Domain) ?Att
                                               (and
                                                 (type ?Val ?Domain) ))))))))))

(#type ConfusionMatrix
  (type.kv-tuple [
                 attributes:^list
                 matrix:(type.matrix) ]))

(#interface classification-function
  (
    uri:org.aiddl.common.learning.supervised.classification-function
    input:^$DataPoint
    output:$Class))
    
(#interface regression-function
  (
    uri:org.aiddl.common.learning.supervised.regression-function
    input:^$DataPoint
    output:^numerical))
    