(#mod self org.aiddl.common.optimization.combinatorial.tsp)

(#nms EVAL org.aiddl.eval)

(#req C org.aiddl.common)
(#req G org.aiddl.common.math.graph)

(#type Node ^term)

(#type Choice (has-type.sig [^numerical (has-type.kvp ^$Node:^$Node)]))

(#type Path (has-type.list ^$Choice
             constraint:(lambda ?X
                          (forall ?i (domain {min:0 step:1 max:(- (size ?X) 1)})
                            (match ?A:?B (last (get-idx ?i ?X))
                              (cond
                                (> ?i 0):(= ?A (value (last (get-idx (- ?i 1) ?X))))
                                true:true
                              ))))))))

(#def Tour
  (and
    (has-type #self ^list)
    (or
      (= (size #self) 0)    
      (forall ?i (domain {min:0 step:1 max:(- (size #self) 1)})
        (and
          (has-type (first (get-idx ?i #self)) ^numerical)
          (match ?A:?B (last (get-idx ?i #self))
            (and
              (has-type ?A ^$Node)
              (has-type ?B ^$Node)
              (cond
                (= ?i 0):(= ?A (value (last (get-idx (- (size #self) 1) #self))))
                true    :(= ?A (value (last (get-idx (- ?i 1) #self))))
              ))))))))
        
  

(#def Problem
  (and
    (has-type #self ^tuple)
    (signature #self [^Graph@G {^fun-ref ^WeightMap@G}])
    
))

(#interface
  heuristic
  (
    uri:(sym-concat $self heuristic)
    input:^$Path
    output:^numerical
  ))

(#interface
  expansion
  (
    uri:(sym-concat $self expansion)
    input:^$Path
    output:(ListGen@C ^$Choice)
  ))

