(#mod self org.aiddl.common.optimization.combinatorial.tsp)
(#req EVAL org.aiddl.eval.namespace)
(#nms E basic@EVAL)

(#req C org.aiddl.common)
(#req G org.aiddl.common.math.graph)

(#type Node ^term)

(#type Choice (type.sig [^numerical (type.kvp ^$Node:^$Node)]))

(#type Path (type.list ^$Choice
             constraint:(lambda ?X
                          (forall ?i (domain {min:0 step:1 max:(- (size ?X) 1)})
                            (match ?A:?B (last (get-idx ?i ?X))
                              (cond
                                (> ?i 0):(= ?A (value (last (get-idx (- ?i 1) ?X))))
                                true:true
                              ))))))

(#type Tour
  (union [^$Path]
   constraint:(lambda ?X 
                (= (key (last (first ?X))) (value (last (last ?X)))))))     

(#type Problem
  (type.sig [^Graph@G (type.union {^fun-ref ^WeightMap@G})]))

(#interface
  heuristic
  (
    uri:(sym-concat $self heuristic)
    input:^$Path
    output:^numerical
  ))

(#interface
  expansion
  (
    uri:(sym-concat $self expansion)
    input:^$Path
    output:(ListGen@C ^$Choice)
  ))

