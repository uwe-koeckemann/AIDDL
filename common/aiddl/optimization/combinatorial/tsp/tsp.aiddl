(#mod self org.aiddl.common.optimization.combinatorial.tsp)
(#req EVAL org.aiddl.eval.namespace)
(#nms E basic@EVAL)

(#req C org.aiddl.common)
(#req G org.aiddl.common.math.graph)

(#type Node ^term)

(#type Choice (type.sig [^numerical (type.kvp ^$Node:^$Node)]))

(#type Path (type.list ^$Choice
             constraint:(lambda ?X
                          (forall ?i (domain {min:0 step:1 max:(- (size ?X) 1)})
                            (match ?A:?B (last (get-idx ?i ?X))
                              (cond
                                (> ?i 0):(= ?A (value (last (get-idx (- ?i 1) ?X))))
                                true:true
                              ))))))

(#def Tour
  (and
    (has-type #self ^list)
    (or
      (= (size #self) 0)    
      (forall ?i (domain {min:0 step:1 max:(- (size #self) 1)})
        (and
          (has-type (first (get-idx ?i #self)) ^numerical)
          (match ?A:?B (last (get-idx ?i #self))
            (and
              (has-type ?A ^$Node)
              (has-type ?B ^$Node)
              (cond
                (= ?i 0):(= ?A (value (last (get-idx (- (size #self) 1) #self))))
                true    :(= ?A (value (last (get-idx (- ?i 1) #self))))
              ))))))))
        


(#type Problem
  (type.sig [^Graph@G (type.union {^fun-ref ^WeightMap@G})])
)

(#interface
  heuristic
  (
    uri:(sym-concat $self heuristic)
    input:^$Path
    output:^numerical
  ))

(#interface
  expansion
  (
    uri:(sym-concat $self expansion)
    input:^$Path
    output:(ListGen@C ^$Choice)
  ))

