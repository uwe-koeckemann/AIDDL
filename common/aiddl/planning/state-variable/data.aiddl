(#mod self org.aiddl.common.planning.state-variable.data)

(#req EVAL org.aiddl.eval.namespace)
(#nms E type-ops@EVAL)

(#req C  org.aiddl.common)
(#req G  org.aiddl.common.math.graph)
(#req P  org.aiddl.common.planning.state-variable)
(#req FL org.aiddl.common.reasoning.logic.first-order)


(#type CausalGraph (TypedDiGraph@G ^AtomOrSymbol@P))

(#type DomainTransitionGraph
  (inter
    (TypedDiGraph@G ^AtomOrSymbol@P)
    (dict [labels:(set-of (typed-kvp ^AtomOrSymbol@P:(set-of ^StateVariableAssignments@P)))])
  ))

(#type DomainTransitionGraphs (set-of ^$DomainTransitionGraph))

(#def RelaxedPlanningGraph
  (and
    (has-type #self ^list)
    (let
      [?O:(reduce (lambda (?c ?x) (union {(get-idx ?x #self) ?c}))
         (filter (lambda ?x (= (modulo ?x 2) 1)) (domain {min:0 max:(- (size #self) 1)}))
         initial-value:{})
       ?P:(reduce (lambda (?c ?x) (union {(get-idx ?x #self) ?c}))
         (filter (lambda ?x (= (modulo ?x 2) 0)) (domain {min:0 max:(- (size #self) 1)}))
         initial-value:{})]
      (and
           (forall ?e ?P
              (has-type ?e ^StateVariableAssignment@P))
            (forall ?e ?O
              (has-type ?e ^Operator@P) )))))


(#interface causal-graph-creator (
  uri    : (sym-concat $self causal-graph-creator)
  input  : ^Operators@P
  output : ^$CausalGraph) )

(#interface domain-transition-graph-creator (
  uri    : (sym-concat $self domain-transition-graph-creator)
  input  : ^Operators@P
  output : ^$DomainTransitionGraphs ))

(#interface relaxed-planning-graph-creator (
  uri    : (sym-concat $self rpg-creator)
  input  : ^Problem@P
  output : ^$RelaxedPlanningGraph
))
