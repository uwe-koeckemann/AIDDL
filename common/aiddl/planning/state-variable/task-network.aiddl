(#mod self org.aiddl.common.planning.task-network)

(#req EVAL   org.aiddl.eval.namespace)
(#nms E      basic@EVAL)

(#req C   org.aiddl.common)
(#req G   org.aiddl.common.math.graph)
(#req FOL org.aiddl.common.reasoning.logic.first-order)
(#req SVP org.aiddl.common.planning.state-variable)
(#req P   org.aiddl.common.planning.state-variable.plan)

(#def Task (has-type #self ^Atom@FOL))

(#def TotallyOrderedTaskNetwork
  (and
    (has-type #self ^list)
    (forall ?e #self
      (has-type ?e ^Atom@FOL))))

(#def DigraphTaskNetwork
  (has-type #self (Graph $Task DirectedEdge@G)@G))

(#def TaskNetwork
  (or
    (has-type #self $TotallyOrderedTaskNetwork)
    (has-type #self $DigraphTaskNetwork)
))

(#def SimpleTaskNetworkMethod
  (and
    (has-type #self ^tuple)
    (has-type (get-key name #self) ^Atom@FOL)
    (has-type (get-key task #self) ^Atom@FOL)
    (has-type (get-key preconditions #self) ^StateVariableAssignments@SVP)
    (has-type (get-key sub-tasks #self) ^Atom@FOL)        
))

(#def TotallyOrderedSimpleTaskNetworkMethod
  (and
    (has-type #self ^tuple)
    (has-type (get-key name #self) ^Atom@FOL)
    (has-type (get-key task #self) ^Atom@FOL)
    (has-type (get-key preconditions #self) ^StateVariableAssignments@SVP)
    (has-type (get-key sub-tasks #self) ^$TotallyOrderedTaskNetwork)     
))

(#def TotalOrderStnProblem
  (and
    (has-type #self ^tuple)
    (has-type (get-key initial-state #self) ^StateVariableAssignments@SVP)
    (has-type (get-key open-tasks #self)  ^$TotallyOrderedTaskNetwork)
    (has-type (get-key operators #self)  ^Operators@SVP)
    (has-type (get-key methods #self)  (SetGen@C ^$TotallyOrderedSimpleTaskNetworkMethod))       
))

(#def HtnMethod NIL)

(#def Constraints NIL)


(#interface
  total-order-stn-planner
  (
    uri:(sym-concat $self total-order-stn-planner)
    input:^$TotalOrderStnProblem
    output:^Plan@P
  ))