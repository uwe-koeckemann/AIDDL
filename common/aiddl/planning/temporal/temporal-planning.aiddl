(#mod self org.aiddl.common.planning.temporal)

(#nms EVAL "eval-ht.aiddl")

(#req C org.aiddl.common)
(#req FoL org.aiddl.common.reasoning.logic.first-order)
(#req T org.aiddl.common.reasoning.temporal)
(#req SVP org.aiddl.common.planning.state-variable)
(#req P org.aiddl.common.planning.state-variable.plan)
(#req AIC org.aiddl.common.reasoning.temporal.allen-interval)

(#def DurativeOperator
  (#and
    (#type #self ^Operator@SCP)
    (#let [?D:(#get-key duration #self)]
      (#type ?D ^Interval@T) )))

(#def Statement
  (#and
    (#match (?I ?SV ?A) #self
      (#type ?I ^Interval@AIC)
      (#type ?SV ^Atom@FoL)
      (#type ?A  ^Atom@FoL)
)))

(#def Statements
  (#type #self (SetGen@C ^$Statement)))

(#def Goals
  (#type #self (SetGen@C ^$Statement)))
    
(#def IntervalOperator
  (#and
    (#type #self ^#tuple)
    (#let [
            ?N : (#get-key name #self)
            ?P : (#get-key preconditions #self)
            ?E : (#get-key effects #self)
            ?C : (#get-key constraints #self)            
          ]
      (#and
        (#type ?N ^Atom@FL)
        (#type ?P ^$Statements
        (#type ?E ^$Statements)
        (#type (#get-key temporal ?C) ^AllenConstraints@AIC)
)))))

(#interface plan2allen-interval (
  uri    : (#sym-concat $self plan2allen-interval)
  input  : (KeyValuedType@C
             [
               state:^State@SVP
               plan:^Plan@P
             ]
           )
  output : ^AllenConstraints@AIC
))