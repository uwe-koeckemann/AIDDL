(#mod self org.aiddl.common.planning.temporal)

(#req EVAL org.aiddl.eval.namespace)
(#nms E hashtag@EVAL)

(#req C org.aiddl.common)
(#req FoL org.aiddl.common.reasoning.logic.first-order)
(#req T org.aiddl.common.reasoning.temporal)
(#req SVP org.aiddl.common.planning.state-variable)
(#req P org.aiddl.common.planning.state-variable.plan)
(#req AIC org.aiddl.common.reasoning.temporal.allen-interval)

(#def DurativeOperator
  (#and
    (#has-type #self ^Operator@SCP)
    (#let [?D:(#get-key duration #self)]
      (#has-type ?D ^Interval@T) )))

(#def Statement
  (#and
    (#match (?I ?SV ?A) #self
      (#has-type ?I ^Interval@AIC)
      (#has-type ?SV ^Atom@FoL)
      (#has-type ?A  ^Atom@FoL)
)))

(#def Statements
  (#has-type #self (SetGen@C ^$Statement)))

(#def Goals
  (#has-type #self (SetGen@C ^$Statement)))
    
(#def IntervalOperator
  (#and
    (#has-type #self ^#tuple)
    (#let [
            ?N : (#get-key name #self)
            ?P : (#get-key preconditions #self)
            ?E : (#get-key effects #self)
            ?C : (#get-key constraints #self)            
          ]
      (#and
        (#has-type ?N ^Atom@FL)
        (#has-type ?P ^$Statements
        (#has-type ?E ^$Statements)
        (#has-type (#get-key temporal ?C) ^AllenConstraints@AIC)
)))))

(#interface plan2allen-interval (
  uri    : (#sym-concat $self plan2allen-interval)
  input  : (KeyValuedType@C
             [
               state:^State@SVP
               plan:^Plan@P
             ]
           )
  output : ^AllenConstraints@AIC
))