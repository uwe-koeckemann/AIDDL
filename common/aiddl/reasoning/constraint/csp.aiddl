(#mod self org.aiddl.common.reasoning.constraint)

(#nms EVAL org.aiddl.eval-ht)

(#req C org.aiddl.common)

(#def Variable
  (#has-type #self ^#variable))

(#def Value
  (#or
    (#has-type #self ^#symbolic)
    (#has-type #self ^#integer) ))

(#def EnumDomain
  (#and
    (#has-type #self ^#set)
    (#forall ?e #self
      (#has-type ?e ^#symbolic) )))

(#def IntegerDomain
  (#and
    (#has-type #self ^#set)
    (#or
      (#forall ?e #self (#has-type ?e ^#integer))
      (#and
        (#has-type (#get-key min #self) ^#integer)
        (#has-type (#get-key max #self) ^#integer))
      )))


(#def Domain
  (#or (#has-type #self ^$EnumDomain) (#has-type #self ^$IntegerDomain) ))

(#def VariableDomain
  (#match ?k:?v #self
    (#and
      (#has-type ?k ^$Variable)
      (#has-type ?v ^$Domain) )))

(#def ValueAssignment
  (#match ?k:?v #self
    (#and
      (#has-type ?k ^$Variable)
      (#has-type ?v ^$Value) )))

(#def TabularConstraint
  (#and
    (#has-type #self ^#list)
    (#let [?Size:(#size (#first #self))]
      (#forall ?e #self
        (#equals (#size ?e) ?Size)))))
  
(#def FunctionURI (#has-type #self ^#symbolic))

(#def Constraint
  (#match (?Scope ?Definition) #self
    (#and
      (#signature ?Scope [^$Variable])
      (#or
        (#has-type ?Definition ^$TabularConstraint)
        (#has-type ?Definition ^$FunctionURI)
        (#has-type ?Definition ^#fun-ref)        
        (#matches (#lambda ?X ?F) ?Definition )
      ))))

(#def Problem
  (#match (?X ?D ?C) #self
    (#and
      (#has-type ?X (SetGen@C ^$Variable))
      (#has-type ?D (SetGen@C ^$VariableDomain))
      (#has-type ?C (SetGen@C ^$Constraint))

      (#forall ?x:?d ?D (#in ?x ?X))
      (#forall (?Scope ?Def) ?C
        (#and
          (#forall ?x ?Scope (#in ?x ?X))
          (#if
            (#has-type ?Def ^$TabularConstraint)
              (#let [?Size:(#size ?Scope)]
                (#forall ?row ?Def
                  (#forall ?i (#domain {min:0 max:?Size})
                    (#contains-match (#get-key (#get-idx ?i ?Scope) ?D) (#get-idx ?i ?row)) )))
            true) )))))

(#def Assignment
  (#and
    (#has-type #self ^#collection)
    (#forall ?e #self
      (#has-type ?e ^$ValueAssignment) )))

(#interface solver
  (
    uri:org.aiddl.common.reasoning.csp.solver
    input:^$Problem
    output:^$Assignment
  )
)

(#interface variable-ordering
  (
    uri:(#sym-concat $self variable-ordering)
    input:(KeyValuedType@C [csp:^$Problem a:^$Assignment])
    output:^$Variable
  )
)

(#interface value-ordering
  (
    uri:(#sym-concat $self value-ordering)
    input:(KeyValuedType@C [csp:^$Problem a:^$Assignment x:^$Variable])
    output:^$Assignment
  )
)

(#interface constraint-tester
  (
    uri:(#sym-concat $self constraint-tester)
    input:^$Assignment
    output:^#boolean
  )
)
