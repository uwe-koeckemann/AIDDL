(#mod self org.aiddl.common.reasoning.resource)

(#req EVAL org.aiddl.eval.namespace)

(#nms nms-type type-ops@EVAL)
(#nms nms-logic logic-ops@EVAL)

(#req C org.aiddl.common)
(#req FoL org.aiddl.common.reasoning.logic.first-order)
(#req AC org.aiddl.common.reasoning.temporal.allen-interval)
(#req STP org.aiddl.common.reasoning.temporal.stp)

(#type Resource (union [^symbolic ^Atom@FoL]))
(#type Activity (union [^symbolic Atom@FoL]))

(#type Capacity
  (typed-kvp ^$Resource:(dict [min:^integer max:^integer])))   

(#type Change (typed-kvp ^$Resource:(sig [(enum {+ - =}) ^integer])))

(#type Peak (set-of ^$Activity))

(#type UsageTuple (sig [^Interval@AC ^$Resource ^integer]))

(#type TupleUsages (set-of ^$UsageTuple))

(#type Usages (col-of (typed-kvp ^$Activity:^$integer)))

(#type RcpspCapacities (col-of ^$Capacity
  constraint:(org.aiddl.eval.lambda ?x
               (forall ?cap ?x
                 (org.aiddl.eval.equals 0 (org.aiddl.eval.get-key min ?cap))))))

(#type RCPSP
  (dict [
    capacity:RcpspCapacities  
    usage:^$Usages
    constraints:^AllenConstraints@AC
  ]))

(#interface variable-value-ordering
  (
    uri:(#sym-concat $self variable-value-ordering)
    input:(TypedTuple@C (SetGen@C ^$Peak) ^Solution@STP) 
    output:(ListGen@C ^AllenConstraint@AC)))

(#interface mcs-collector
  (
    uri:(#sym-concat $self peak-collector)
    input:(KeyValuedType@C usage:^$Usage times:^IntervalDomainLookup@STP) 
    output:(SetGen@C ^$Peak)))